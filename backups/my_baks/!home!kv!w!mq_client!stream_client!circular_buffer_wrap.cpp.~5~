
#include <boost/thread/mutex.hpp>
#include <boost/thread/condition.hpp>
#include <boost/thread/thread.hpp>
#include <boost/call_traits.hpp>
#include <boost/progress.hpp>
#include <boost/bind.hpp>

#include <boost/circular_buffer.hpp>

template <class T>
class circular_buffer_wrap {
public:
  typedef boost::circular_buffer_space_optimized<T> container_type;
  typedef typename container_type::size_type size_type;
  typedef typename container_type::value_type value_type;
  typedef typename boost::call_traits<value_type>::param_type param_type;
  explicit circular_buffer_wrap(size_type capacity) : m_unread(0), m_container(capacity) {}

  void push_front(param_type item) {
    // param_type represents the "best" way to pass a parameter of type value_type to a method
    
    boost::mutex::scoped_lock lock(m_mutex);
    // TODO: we should add a knobe specifying the behaviour in the case of full buffer: 
    // to wait or to enlarge the buffer
    // m_not_full.wait(lock, boost::bind(&circular_buffer_wrap<value_type>::is_not_full, this));
    if (m_container.full()) 	// resizing the buffer
      // TODO_release: add checking of data usage: delete no longer needed chunks
      m_container.set_capacity( size_type(m_container.capacity() + 10)); // number 10 is added as a "rule of thumb"
    m_container.push_front(item);
    ++m_unread;
    lock.unlock();
    m_not_empty.notify_one();
  };
  
  void pop_back(value_type* pItem) {
    boost::mutex::scoped_lock lock(m_mutex);
    m_not_empty.wait(lock, boost::bind(&circular_buffer_wrap<value_type>::is_not_empty, this));
    *pItem = m_container[--m_unread];
    lock.unlock();
    m_not_full.notify_one();
  };
  
private:
  circular_buffer_wrap(const circular_buffer_wrap&);              // Disabled copy constructor
  circular_buffer_wrap& operator = (const circular_buffer_wrap&); // Disabled assign operator

  bool is_not_empty() const { return m_unread > 0; }
  bool is_not_full() const { return m_unread < m_container.capacity(); }

  size_type m_unread;
  container_type m_container;
  boost::mutex m_mutex;
  boost::condition m_not_empty;
  boost::condition m_not_full;
};
