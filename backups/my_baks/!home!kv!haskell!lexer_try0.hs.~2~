
module Query.Lexer where

import Text.Parsec
import qualified Text.Parsec.Token as PT
import Text.Parsec.Language ( emptyDef )


import Control.Applicative
import Control.Monad.Identity

-- import Text.Parsec.String
-- import Text.Parsec.Pos
-- import Text.Parsec.Expr
-- import Text.Parsec.Perm

lexer  = PT.makeTokenParser  (emptyDef {
                             PT.commentStart = "/*"
                            ,PT.commentEnd = "*/"
                            ,PT.commentLine = "--"
                            ,PT.nestedComments = False
                            ,PT.identStart = letter <|> char '_'
                            ,PT.identLetter    = alphaNum <|> oneOf "_"
                            ,PT.opStart        = PT.opLetter emptyDef
                            ,PT.opLetter       = oneOf ".:^*/%+-<>=|!"
                            ,PT.reservedOpNames= []
                            ,PT.reservedNames  = []
                            ,PT.caseSensitive  = False
                            })

-- For efficiency, we bind all the used lexical parsers at toplevel.
whiteSpace= PT.whiteSpace lexer
lexeme    = PT.lexeme lexer
symbol    = PT.symbol lexer
natural   = PT.natural lexer
parens    = PT.parens lexer
semi      = PT.semi lexer
identifier= PT.identifier lexer
reserved  = PT.reserved lexer
reservedOp= PT.reservedOp lexer


-- data types

type Token = (SourcePos, Tok)
data Tok = QueryString String String  -- delim, value (delim will one of ', $$, $[stuff]$
         | QueryIdString String       -- includes . and x.y.* type stuff
         | QuerySymbol String         -- operators, and ()[],;:* is currently always lexed as an id
                                    --   rather than an operator
                                    -- this gets fixed in the parsing stage
         | QueryPositionalTok Integer -- used for $1, etc.
         | QueryFloatTok Double
         | QueryIntegerTok Integer
         deriving (Eq,Show)

