
module Main where

import Text.ParserCombinators.Parsec
import Text.Parsec hiding(many, optional, (<|>))
import qualified Text.ParserCombinators.Parsec.Token as P
import Text.ParserCombinators.Parsec.Language
import Text.Parsec.String
import Text.ParserCombinators.Parsec.Pos

import Control.Applicative
import Control.Monad.Identity

-- run :: Show a => Parser a -> String -> IO ()
--        run p input 
--   = case (parse p "queryParser" input) of 
--     Left err -> do {putStr "parse error at "
--                    ; print err
--                    }
--     Right x -> print x
    

-- simple :: Parser Char
-- simple = letter

-- parens :: Parser ()
-- parens = do {char '('
--             ; parens
--             ; char ')'
--             ; parens
--             }
--          <|> return ()
         
         
-- nesting :: Parser Int
-- nesting = do { char '('
--              ; n <- nesting
--              ; char ')'
--              ; m <- nesting
--              ; return (max (n+1) m)
--              }
--           <|> return 0

-- =========================================

parseSql :: String      -- ^ filename to use in errors
            -> String   -- ^ a string containing the sql to parse
            -> Either ParseErrorExtra StatementList
parseSql f s = parseIt (lexSqlText f s) sqlStatements f Nothing s startState

lexSqlText :: String -> String -> Either ParseErrorExtra [Token]
lexSqlText f s = toParseErrorExtra (runParser sqlTokens [] f s) Nothing s


sqlStatements :: ParsecT [Token] ParseState Identity [Statement]
sqlStatements = many (sqlStatement True) <* eof

-- parse a statement

sqlStatement :: Bool -> ParsecT [Token] ParseState Identity Statement
sqlStatement reqSemi =
  (choice [
      selectStatement
--      ,insert
--      ,update
--      ,delete
--      ,truncateSt
--      ,copy
--      ,set
--      ,notify
--       ,keyword "create" *>
--        choice [
--          createTable
--          ,createSequence
--          ,createType
--          ,createFunction
--          ,createView
--          ,createDomain
--          ,createLanguage
--          ,createTrigger]
--       ,keyword "alter" *>
--        choice [
--          alterSequence
--          ,alterTable]
--       ,keyword "drop" *>
--        choice [
--          dropSomething
--          ,dropFunction]]
      ])
   <* (if reqSemi
       then symbol ";" >> return ()
       else optional (symbol ";") >> return ())
  <|> copyData
                   

selectStatement :: ParsecT [Token] ParseState Identity Statement
selectStatement = SelectStatement <$> pos <*> selectExpression

selectExpression :: ParsecT [Token] ParseState Identity SelectExpression
-- selectExpression =
--   buildExpressionParser combTable selFactor
--     where
--       selFactor = try (parens selectExpression) <|> selQuerySpec <|> values
--                   combTable = [map (\(c,p) -> Infix (CombineSelect <$> pos <*> (c <$ p)) AssocLeft)
--                                [(Except, keyword "except")
--                                ,(Intersect, keyword "intersect")
--                                ,(UnionAll, try (keyword "union" *> keyword "all"))
--                                ,(Union, keyword "union")]]
--                  selQuerySpec = Select <$> (pos <* keyword "select")
--                                 <*> option Dupes (Distinct <$ keyword "distinct")
--                                 <*> selectList
--                                 <*> option [] from
--                                 <*> optionMaybe whereClause
--                                 <*> option [] groupBy
--                                 <*> optionMaybe having
--                  <*> option [] orderBy
--                  <*> optionMaybe limit
--                  <*> optionMaybe offset
--   from = keyword "from" *> commaSep1 tref
--   groupBy = keyword "group" *> keyword "by"
--             *> commaSep1 expr
--   having = keyword "having" *> expr
--   orderBy = keyword "order" *> keyword "by"
--             *> commaSep1 oneOrder
--   oneOrder = (,) <$> expr
--              <*> option Asc (choice [
--                                 Asc <$ keyword "asc"
--                                 ,Desc <$ keyword "desc"])
--   limit = keyword "limit" *> expr
--   offset = keyword "offset" *> expr
--          -- table refs
--   -- have to cope with:
--   -- a simple tableref i.e just a name
--   -- an aliased table ref e.g. select a.b from tbl as a
--   -- a sub select e.g. select a from (select b from c)
--   --  - these are handled in tref
--   -- then cope with joins recursively using joinpart below
--   tref = buildExpressionParser [] trefFactor
--   trefFactor = threadOptionalSuffix (nonJoinTref <|> try (parens tref)) joinPart <|> parens tref
--   --tref = optParens (threadOptionalSuffix (try (parens tref) <|> nonJoinTref) joinPart)
--   nonJoinTref = try $ optParens $ do
--     p2 <- pos
--           choice [
--             SubTref p2
--             <$> parens selectExpression
--             <*> palias
--             ,TrefFun p2
--              <$> try (identifier >>= functionCallSuffix)
--              <*> palias
--             ,Tref p2
--              <$> nkwid
--              <*> palias]
--     --joinpart: parse a join after the first part of the tableref
--     --(which is a table name, aliased table name or subselect) -
--     --takes this tableref as an arg so it can recurse to multiple
--     --joins
--     joinPart tr1 = threadOptionalSuffix (readOneJoinPart tr1) joinPart
--     readOneJoinPart tr1 = do
--       p2 <- pos
--       JoinedTref p2 tr1
--         --look for the join flavour first
--         <$> option Unnatural (Natural <$ keyword "natural")
--         <*> choice [
--           LeftOuter <$ try (keyword "left" *> optional (keyword "outer"))
--           ,RightOuter <$ try (keyword "right" *> optional (keyword "outer"))
--           ,FullOuter <$ try (keyword "full" >> optional (keyword "outer"))
--           ,Cross <$ keyword "cross"
--           ,Inner <$ optional (keyword "inner")]
--         --recurse back to tref to read the table
--         <*> (keyword "join" *> tref)
--         --now try and read the join condition
--         <*> choice [
--           Just <$> (JoinOn <$> pos <*> (keyword "on" *> expr))
--           ,Just <$> (JoinUsing <$> pos <*> (keyword "using" *> columnNameList))
--           ,return Nothing]
--         <*> palias
--         palias = option NoAlias
--                  (optionalSuffix
--                   TableAlias (optional (keyword "as") *> nkwid)
--                   FullAlias () (parens $ commaSep1 idString))
--       nkwid = try $ do
--         x <- idString
--              --avoid all these keywords as aliases since they can
--              --appear immediately following a tableref as the next
--              --part of the statement, if we don't do this then lots
--              --of things don't parse. Seems a bit inelegant but
--              --works for the tests and the test sql files don't know
--              --if these should be allowed as aliases without "" or
--              --[]
--              -- TODO find out what the correct behaviour here is.
--              if map toLower x `elem` ["as"
-- ,"where"
--                              ,"except"
--                              ,"union"
--                              ,"intersect"
--                              ,"loop"
--                              ,"inner"
--                              ,"on"
--                              ,"left"
--                              ,"right"
--                              ,"full"
--                              ,"cross"
--                              ,"join"
--                              ,"natural"
--                              ,"order"
--                              ,"group"
--                              ,"limit"
--                              ,"using"
--                              ,"from"]
--                    then fail "not keyword"
--                    else return x
--         values = Values <$> (pos <* keyword "values") <*> commaSep1 (parens $ commaSep1 expr)


type Token = (SourcePos, Tok)

data Tok = StringTok String String  -- delim, value (delim will one of
           -- ', $$, $[stuff]$
         | IdStringTok String       -- includes . and x.y.* type stuff
         | SymbolTok String         -- operators, and ()[],;:
           -- '*' is currently always lexed as an id
           --   rather than an operator
           -- this gets fixed in the parsing stage
         | PositionalArgTok Integer -- used for $1, etc.
         | FloatTok Double
         | IntegerTok Integer
         | CopyPayloadTok String -- support copy from stdin; with inline data
         deriving (Eq,Show)

whiteSpace :: ParsecT String LexState Identity ()
whiteSpace= P.whiteSpace lexer

type LexState = [Tok]

sqlTokens :: ParsecT String LexState Identity [Token]
sqlTokens =
  setState [] >>
  whiteSpace >>
  many sqlToken <* eof

whiteSpace :: ParsecT String LexState Identity ()
whiteSpace= P.whiteSpace lexer

type LexState = [Tok]


lexer :: P.GenTokenParser String LexState Identity
lexer = P.makeTokenParser (emptyDef {
                              P.commentStart = "/*"
                              ,P.commentEnd = "*/"
                              ,P.commentLine = "--"
                              ,P.nestedComments = False
                              ,P.identStart = letter <|> char '_'
                              ,P.identLetter    = alphaNum <|> oneOf "_"
                              ,P.opStart        = P.opLetter emptyDef
                              ,P.opLetter       = oneOf opLetters
                              ,P.reservedOpNames= []
                              ,P.reservedNames  = []
                              ,P.caseSensitive  = False
                              })
        
keyword :: String -> ParsecT [Token] ParseState Identity ()
keyword k = mytoken (\tok ->
                      case tok of
                        IdStringTok i | lcase k == lcase i -> Just ()
                        _ -> Nothing)
  where
    lcase = map toLower

mytoken :: (Tok -> Maybe a) -> MyParser a
mytoken test
  = token showToken posToken testToken
    where
      showToken (_,tok)   = show tok
  posToken  (posi,_)  = posi
  testToken (_,tok)   = test tok

toParseErrorExtra :: Either ParseError b -> Maybe (Int,Int) -> String -> Either ParseErrorExtra b
toParseErrorExtra a sp src = case a of
  Left pe -> Left $ ParseErrorExtra pe sp src
             Right x -> Right x


data ParseErrorExtra = ParseErrorExtra {
  -- | wrapped error
  parseErrorError :: ParseError
                     -- | source position
                     -- adjustment to get the
                     -- context bit in error
                     -- messages right - this is
                     -- the same as what is passed
                     -- into parseSqlWithPosition
  ,parseErrorPosition :: (Maybe (Int, Int))
                         -- | sql source
  ,parseErrorSqlSource :: String
  }
