
#include "circular_buffer_wrap.hpp"

explicit circular_buffer_wrap(size_type capacity) : m_unread(0), m_container(capacity) {}

void push_front(param_type item) {
  // param_type represents the "best" way to pass a parameter of type value_type to a method

  boost::mutex::scoped_lock lock(m_mutex);
  // TODO: we should add a knobe specifying the behaviour in the case of full buffer: 
  // to wait or to enlarge the buffer
  // m_not_full.wait(lock, boost::bind(&circular_buffer_wrap<value_type>::is_not_full, this));
  if (m_container.full()) 	// resizing the buffer
    // TODO_release: add checking of data usage: delete no longer needed chunks
    m_container.set_capacity( size_type(m_container.capacity() + 10)); // number 10 is added as a "rule of thumb"
  m_container.push_front(item);
  ++m_unread;
  lock.unlock();
  m_not_empty.notify_one();
}

void pop_back(value_type* pItem) {
  boost::mutex::scoped_lock lock(m_mutex);
  m_not_empty.wait(lock, boost::bind(&circular_buffer_wrap<value_type>::is_not_empty, this));
  *pItem = m_container[--m_unread];
  lock.unlock();
  m_not_full.notify_one();
}

  bool is_not_empty() const { return m_unread > 0; }
  bool is_not_full() const { return m_unread < m_container.capacity(); }

