


module Query.Lexer where

import Text.Parsec hiding(many, optional, (<|>))
import qualified Text.Parsec.Token as P
import Text.Parsec.Language
import Text.Parsec.String
import Text.Parsec.Pos
import Text.Parsec.Expr
import Text.Parsec.Perm


import Control.Applicative
import Control.Monad.Identity

type Token = (SourcePos, Tok)

type MySourcePos = (String,Int,Int)
type ParseState = [MySourcePos]

== lexer stuff

type MyParser = GenParser Token ParseState
 
mytoken :: (Tok -> Maybe a) -> MyParser a
mytoken test
  = token showToken posToken testToken
where
  showToken (_,tok)   = show tok
  posToken  (posi,_)  = posi
  testToken (_,tok)   = test tok

data Tok = StringTok String String  -- delim, value (delim will one of ', $$, $[stuff]$
         | IdStringTok String       -- includes . and x.y.* type stuff
         | SymbolTok String         -- operators, and ()[],;:
           -- '*' is currently always lexed as an id
           --   rather than an operator
           -- this gets fixed in the parsing stage
         | PositionalArgTok Integer -- used for $1, etc.
         | FloatTok Double
         | IntegerTok Integer
         | CopyPayloadTok String -- support copy from stdin; with inline data
         deriving (Eq,Show)

type LexState = [Tok]

lexSqlText :: String -> String -> [Token]
lexSqlText f s = runParser sqlTokens [] f s Nothing s

sqlTokens :: ParsecT String LexState Identity [Token]
sqlTokens =
  setState [] >>
  whiteSpace >>
  many sqlToken <* eof

whiteSpace :: ParsecT String LexState Identity ()
whiteSpace= P.whiteSpace lexer

lexer :: P.GenTokenParser String LexState Identity
lexer = P.makeTokenParser (emptyDef {
                              P.commentStart = "/*"
                              ,P.commentEnd = "*/"
                              ,P.commentLine = "--"
                              ,P.nestedComments = False
                              ,P.identStart = letter <|> char '_'
                              ,P.identLetter    = alphaNum <|> oneOf "_"
                              ,P.opStart        = P.opLetter emptyDef
                              ,P.opLetter       = oneOf opLetters
                              ,P.reservedOpNames= []
                              ,P.reservedNames  = []
                              ,P.caseSensitive  = False
                              })

opLetters :: String
opLetters = ".:^*/%+-<>=|!"

sqlToken :: ParsecT String LexState Identity Token
sqlToken = do
  sp <- getPosition
  sta <- getState
  t <- if sta == [ft,st,mt]
       then copyPayload
       else try sqlString
            <|> try idString
            <|> try positionalArg
            <|> try sqlSymbol
            <|> try sqlFloat
            <|> try sqlInteger
  updateState $ \stt ->
    case () of
      _ | stt == [] && t == ft -> [ft]
        | stt == [ft] && t == st -> [ft,st]
        | stt == [ft,st] && t == mt -> [ft,st,mt]
        | otherwise -> []
  return (sp,t)
  where
    ft = IdStringTok "from"
    st = IdStringTok "stdin"
    mt = SymbolTok ";"

copyPayload :: ParsecT String LexState Identity Tok
copyPayload = CopyPayloadTok <$> lexeme (getLinesTillMatches "\\.\n")
  where
    getLinesTillMatches s = do
      x <- getALine
      if x == s
        then return ""
        else (x++) <$> getLinesTillMatches s
    getALine = (++"\n") <$> manyTill anyChar (try newline)


sqlString :: ParsecT String LexState Identity Tok
sqlString = stringQuotes <|> stringLD
  where
    --parse a string delimited by single quotes
    stringQuotes = StringTok "\'" <$> stringPar
    stringPar = optional (char 'E') *> char '\''
                *> readQuoteEscape <* whiteSpace
    --(readquoteescape reads the trailing ')
    -- have to read two consecutive single quotes as a quote character
    -- instead of the end of the string, probably an easier way to do this
    -- other escapes (e.g. \n \t) are left unprocessed

    readQuoteEscape = do
      x <- anyChar
      if x == '\''
        then try ((x:) <$> (char '\'' *> readQuoteEscape))
             <|> return ""
        else (x:) <$> readQuoteEscape
    -- parse a dollar quoted string
    stringLD = do
      -- cope with $$ as well as $[identifier]$
               tag <- try (char '$' *> ((char '$' *> return "")
                                   <|> (identifierString <* char '$')))
               s <- lexeme $ manyTill anyChar
                      (try $ char '$' <* string tag <* char '$')
               return $ StringTok ("$" ++ tag ++ "$") s

identifierString :: ParsecT String LexState Identity String
identifierString = lexeme $ choice [
                    "*" <$ symbol "*"
                    ,do
                      a <- nonStarPart
                      b <- tryMaybeP ((++) <$> symbol "." <*> identifierString)
                      case b of Nothing -> return a
                                Just c -> return $ a ++ c]
  where
    nonStarPart = idpart <|> (char '"' *> many (noneOf "\"") <* char '"')
                  where idpart = (letter <|> char '_') <:> secondOnwards
    secondOnwards = many (alphaNum <|> char '_')

tryMaybeP :: GenParser tok st a
             -> ParsecT [tok] st Identity (Maybe a)
tryMaybeP p = try (optionMaybe p) <|> return Nothing

symbol :: String -> ParsecT [Token] ParseState Identity ()
symbol c = mytoken (\tok -> case tok of
                       SymbolTok s | c==s -> Just ()
                       _           -> Nothing)

integer :: MyParser Integer
integer = mytoken (\tok -> case tok of
                      IntegerTok n -> Just n
                      _ -> Nothing)

float :: MyParser Double
float = mytoken (\tok -> case tok of
                    FloatTok n -> Just n
                                  _ -> Nothing)

idString :: ParsecT String LexState Identity Tok
idString = IdStringTok <$> identifierString

positionalArg :: ParsecT String LexState Identity Tok
positionalArg = char '$' >> PositionalArgTok <$> integer

lexeme :: ParsecT String LexState Identity a
          -> ParsecT String LexState Identity a
lexeme = P.lexeme lexer

-- this lexer isn't really used as much as it could be, probably some of
-- the fields are not used at all (like identifier and operator stuff)

lexer :: P.GenTokenParser String LexState Identity
lexer = P.makeTokenParser (emptyDef {
                              P.commentStart = "/*"
                              ,P.commentEnd = "*/"
                              ,P.commentLine = "--"
                              ,P.nestedComments = False
                              ,P.identStart = letter <|> char '_'
                              ,P.identLetter    = alphaNum <|> oneOf "_"
                              ,P.opStart        = P.opLetter emptyDef
                              ,P.opLetter       = oneOf opLetters
                              ,P.reservedOpNames= []
                              ,P.reservedNames  = []
                              ,P.caseSensitive  = False
                              })

-- == sql symbols for this lexer:

-- sql symbol is one of
-- ()[],; - single character
-- +-*/<>=~!@#%^&|`? string - one or more of these, parsed until hit char
-- which isn't one of these (including whitespace). This will parse some
-- standard sql expressions wrongly at the moment, work around is to add
-- whitespace e.g. i think 3*-4 is valid sql, should lex as '3' '*' '-'
-- '4', but will currently lex as '3' '*-' '4'. This is planned to be
-- fixed in the parser.
-- .. := :: : - other special cases
-- A single * will lex as an identifier rather than a symbol, the parser
-- deals with this.

sqlSymbol :: ParsecT String LexState Identity Tok
sqlSymbol =
  SymbolTok <$> lexeme (choice [
                           replicate 1 <$> oneOf "()[],;"
                           ,string ".."
                           ,try $ string "::"
                           ,try $ string ":="
                           ,string ":"
                           ,many1 (oneOf "+-*/<>=~!@#%^&|`?")
                           ])

sqlFloat :: ParsecT String LexState Identity Tok
sqlFloat = FloatTok <$> float

sqlInteger :: ParsecT String LexState Identity Tok
sqlInteger = IntegerTok <$> integer
