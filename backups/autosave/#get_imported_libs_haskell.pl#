

#! /usr/bin/perl -w

############################################################
##                                                        ##
##                                                        ##
## Author: Kostya Varakin                                 ##
##                                                        ##
############################################################

BEGIN {
  use Config;
  $Config{useithreads} or die "Recompile Perl with threads to run this program.";
}
use diagnostics;
use strict;
use warnings;
use Carp qw/cluck carp croak confess/;
$Carp::MaxEvalLen = 0;
$Carp::MaxArgLen  = 0;
$Carp::MaxArgNums = 0;

use IO::File;
use threads ('yield',
	     'stack_size' => 64*4096,
	     'exit' => 'threads_only',
	     'stringify');
use threads::shared;
use Thread::Semaphore;
use Thread::Queue;
use Data::Dumper;
use POSIX ":sys_wait_h";
use POSIX qw/strftime/;
use Devel::Peek;
use File::Copy;
use File::Path;
use File::stat;
use Cwd;
use File::Temp qw/tempfile/; # get tempfile name + ilehandle
use IPC::Open3; # open pipe to system cmd and gather control on it STDIN,STDOUT,STDERR
use Symbol;   # manipulate Perl symbols and their names. Symbol::gensym  creates an anonymous 
              #glob and returns a reference to it. Such a glob reference can be used as a file or directory handle.
use Storable; # store and retrieve variables from files
use feature "state";		# for state (persistent) variables

package main;

my ($debug_level, $verbose_level, $input_file) = &parse_cl();

my @include_dirs = qw$/home/kv/haskell/working_version/hssqlppp/$;

my $lib_find = sub {
  my $in_path = shift;
  for (@include_dirs) {
    my $file = "$_"."/".$in_path;
    return $file if -f $file;
  }
  return undef;
};
my @lib_files = split ("\n", `grep 'import ' $input_file | sed -e 's#import\\|>##g' | \
sed -e 's#^\\s\\+##' | grep -vE '^\-\-' | awk '{print \$1}' | sed -e 's#\\.#\/#g'`);
my $stage_name = ($input_file =~ /([^\/]+)\.l?hs$/);
map {
  my $lib_name = ($lib_find->($_.".hs") or $lib_find->($_.".lhs"));
  print $stage_name." : ".
} @lib_files;

print "DDDDDDD\n";


# parse command line
sub parse_cl() {
  use Getopt::Long;
  my ($debug_level, $verbose_level);
  local $SIG{__DIE__} = sub {print "Get DIE signal\n"; &print_usage};
  local $SIG{__WARN__} = sub {print "Warn in usage: @_\n"};
  GetOptions ('debug:i'      => \$debug_level,
	      'verbose:i'    => \$verbose_level,
	      'input_file:s' => \$input_file,
	      'help|?'       => \&print_usage,
	      '<>'           => \&print_usage);
  $debug_level ||= 0;
  $verbose_level ||= 0;
  die "-input_file $input_file does not exist or not readable or zero sized"
    if (!-e $input_file || -z $input_file || !-r $input_file);
  return ($debug_level, $verbose_level, $input_file);
}

sub print_usage() {
  print STDERR "-debug\n-verbose\n-help\n-input_file\n";
  exit 1
}

# END package main
